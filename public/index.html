<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sensillum - Web Proxy Tester</title>
    <style>
        body { font-family: system-ui; background: #f4f4f9; padding: 30px; max-width: 1600px; margin: 0 auto; }
        .header { margin-bottom: 15px; }
        .header-top { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .header-top h2 { margin: 0; color: #2d3436; }
        .status-badge { padding: 8px 16px; border-radius: 20px; color: white; display: inline-flex; align-items: center; gap: 10px; font-size: 0.9rem; }
        .status-text { font-weight: 600; }
        .status-timer { opacity: 0.9; font-weight: normal; }
        .live { background: #00b894; } .dead { background: #d63031; }
        #ws-msg, #sse-msg { color: #636e72; font-size: 0.9em; }
        
        .history {
            margin-top: 40px;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .history h2 { margin-top: 0; color: #2d3436; }
        .history-list { list-style: none; padding: 0; }
        .history-item {
            padding: 12px;
            margin: 8px 0;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #dfe6e9;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .history-item.success { border-left-color: #00b894; }
        .history-item.failure { border-left-color: #d63031; }
        .history-item .time { color: #636e72; font-size: 0.9em; }
        .history-item .duration { font-weight: bold; color: #2d3436; }
        .history-item .status { font-size: 0.9em; }
        .status.error { color: #d63031; }
        .status.closed { color: #636e72; }
        
        .headers {
            margin-top: 20px;
            display: flex;
            gap: 20px;
        }
        .headers-column {
            flex: 1;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .headers-column:first-child h2 { margin-top: 0; color: #2d3436; margin-bottom: 15px; }
        .client-ip {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            border-left: 4px solid #0984e3;
        }
        .server-info {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            border-left: 4px solid #00b894;
        }
        .client-ip strong,
        .server-info strong { color: #2d3436; }
        .client-ip .ip-value,
        .server-info .info-value {
            font-family: monospace;
            color: #0984e3;
            font-size: 1.1em;
            margin-left: 8px;
        }
        .server-info .info-value {
            color: #00b894;
        }
        .headers-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        .headers-table th,
        .headers-table td {
            text-align: left;
            padding: 10px;
            border-bottom: 1px solid #dfe6e9;
        }
        .headers-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2d3436;
        }
        .headers-table td:first-child {
            font-family: monospace;
            color: #0984e3;
        }
        .headers-table td:last-child {
            font-family: monospace;
            color: #2d3436;
            word-break: break-all;
        }
        
        .loadbalancer {
            margin-top: 20px;
            margin-bottom: 40px;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .loadbalancer .lb-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .loadbalancer h2 { margin: 0; color: #2d3436; }
        .loadbalancer button {
            background: #0984e3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 0.9em;
            cursor: pointer;
        }
        .loadbalancer button:hover { background: #0769c0; }
        .loadbalancer button:disabled {
            background: #dfe6e9;
            cursor: not-allowed;
        }
        .lb-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
        }
        .lb-item {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 12px;
            border-left: 4px solid #0984e3;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .lb-item .lb-number {
            font-weight: 600;
            color: #636e72;
            font-size: 0.9em;
        }
        .lb-item .lb-node {
            display: flex;
            align-items: center;
            font-family: monospace;
            color: #2d3436;
        }
        .lb-item .lb-hostname {
            display: flex;
            align-items: center;
            font-family: monospace;
            color: #636e72;
            font-size: 0.9em;
        }
        
        .proxy-test {
            margin-top: 20px;
            margin-bottom: 40px;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .proxy-test .test-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .proxy-test h2 { margin: 0; color: #2d3436; }
        .proxy-test button {
            background: #6c5ce7;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 0.9em;
            cursor: pointer;
        }
        .proxy-test button:hover { background: #5849c7; }
        .proxy-test button:disabled {
            background: #dfe6e9;
            cursor: not-allowed;
        }
        .test-result {
            padding: 15px;
            border-radius: 6px;
            background: #f8f9fa;
            margin-bottom: 10px;
        }
        .test-result.pass {
            border-left: 4px solid #00b894;
        }
        .test-result.fail {
            border-left: 4px solid #d63031;
        }
        .test-result.warning {
            border-left: 4px solid #fdcb6e;
        }
        .test-result .test-name {
            font-weight: 600;
            margin-bottom: 5px;
            color: #2d3436;
        }
        .test-result .test-detail {
            color: #636e72;
            font-size: 0.9em;
            font-family: monospace;
        }
        .test-summary {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
        }
        .test-stat {
            padding: 10px 15px;
            border-radius: 6px;
            text-align: center;
        }
        .test-stat.pass {
            background: #00b894;
            color: white;
        }
        .test-stat.fail {
            background: #d63031;
            color: white;
        }
        .test-stat.warning {
            background: #fdcb6e;
            color: #2d3436;
        }
        .test-stat .count {
            font-size: 1.5em;
            font-weight: bold;
        }
        .test-stat .label {
            font-size: 0.85em;
            margin-top: 3px;
        }
        
        .size-test {
            margin-top: 20px;
            margin-bottom: 40px;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .size-test .test-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .size-test h2 { margin: 0; color: #2d3436; }
        .size-test .button-group {
            display: flex;
            gap: 10px;
        }
        .size-test button {
            background: #e17055;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 0.9em;
            cursor: pointer;
        }
        .size-test button:hover { background: #d63031; }
        .size-test button:disabled {
            background: #dfe6e9;
            cursor: not-allowed;
        }
        .size-result {
            padding: 15px;
            border-radius: 6px;
            background: #f8f9fa;
            border-left: 4px solid #0984e3;
        }
        .size-result .result-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #0984e3;
            margin: 10px 0;
        }
        .size-result .result-detail {
            color: #636e72;
            font-size: 0.9em;
            margin-top: 5px;
        }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #dfe6e9;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: #0984e3;
            transition: width 0.3s ease;
        }
        
        .footer {
            margin-top: 40px;
            padding: 20px;
            text-align: center;
            color: #95a5a6;
            font-size: 0.85em;
            border-top: 1px solid #dfe6e9;
        }
        .footer .version {
            font-family: monospace;
        }
    </style>
    <script>
        // #SERVER_INFO_INJECTION
        const urlPrefix = window.initialServerInfo?.url_prefix || '';
    </script>
</head>
<body>

    <div class="loadbalancer">
        <div class="lb-header">
            <h2>Load Balancer Test</h2>
            <button id="lb-test-btn" onclick="runLoadBalancerTest()">Reload</button>
        </div>
        <div class="lb-grid" id="lb-results">
            <p style="color: #95a5a6; text-align: center; grid-column: 1 / -1;">Loading...</p>
        </div>
    </div>

    <div class="proxy-test">
        <div class="test-header">
            <h2>Proxy Security Test</h2>
            <button id="proxy-test-btn" onclick="runProxySecurityTest()">Run Test</button>
        </div>
        <div id="proxy-test-summary" style="display: none;">
            <div class="test-summary" id="test-summary"></div>
        </div>
        <div id="proxy-test-results">
            <p style="color: #95a5a6; text-align: center;">Click "Run Test" to check if your proxy properly strips spoofed headers</p>
        </div>
    </div>

    <div class="size-test">
        <div class="test-header">
            <h2>Header Size Limit Test</h2>
            <div class="button-group">
                <button id="single-header-test-btn" onclick="runSingleHeaderSizeTest()">Single Header</button>
                <button id="total-header-test-btn" onclick="runTotalHeaderSizeTest()">Total Headers</button>
            </div>
        </div>
        <div id="size-test-results">
            <p style="color: #95a5a6; text-align: center;">Test the maximum size of a single header value, or the total size of all headers combined</p>
        </div>
    </div>

    <div class="size-test">
        <div class="test-header">
            <h2>Invalid Character Test</h2>
            <button id="invalid-char-test-btn" onclick="runInvalidCharacterTest()">Run Test</button>
        </div>
        <div id="invalid-char-test-results">
            <p style="color: #95a5a6; text-align: center;">Test if null bytes and unprintable characters are properly blocked</p>
        </div>
    </div>

    <div class="headers">
        <div class="headers-column">
            <h2>HTTP Request (Page Load)</h2>
            <div id="html-headers-content">
                <p style="color: #95a5a6; text-align: center;">No headers received yet</p>
            </div>
        </div>
        <div class="headers-column">
            <div class="header">
                <div class="header-top">
                    <h2>WebSocket</h2>
                    <div id="ws-status" class="status-badge dead">
                        <span class="status-text">DISCONNECTED</span>
                        <span id="ws-timer" class="status-timer">0s</span>
                    </div>
                </div>
                <p id="ws-msg">Waiting for handshake...</p>
            </div>
            <div id="ws-headers-content">
                <p style="color: #95a5a6; text-align: center;">Not connected</p>
            </div>
        </div>
        <div class="headers-column">
            <div class="header">
                <div class="header-top">
                    <h2>Server-Sent Events</h2>
                    <div id="sse-status" class="status-badge dead">
                        <span class="status-text">DISCONNECTED</span>
                        <span id="sse-timer" class="status-timer">0s</span>
                    </div>
                </div>
                <p id="sse-msg">Waiting for connection...</p>
            </div>
            <div id="sse-headers-content">
                <p style="color: #95a5a6; text-align: center;">Not connected</p>
            </div>
        </div>
    </div>

    <div class="history">
        <h2>Connection History</h2>
        <ul class="history-list" id="history-list">
            <li style="color: #95a5a6; text-align: center;">No connections yet</li>
        </ul>
    </div>

    <script>
        let history = [];
        
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        // Generate a visual insignia (military ribbon style) from hash bytes
        function generateInsignia(hashArray) {
            // Determine number of bars (2-6) from first byte
            const numBars = 2 + (hashArray[0] % 5);
            
            const bars = [];
            let lastHue = -120; // Start offset to ensure first bar contrasts well
            
            for (let i = 0; i < numBars; i++) {
                const offset = i * 4;
                
                // Get base hue from hash
                const baseHue = (hashArray[offset] + (hashArray[offset + 1] << 8)) % 360;
                
                // Ensure at least 90 degrees separation from previous bar for good contrast
                let hue = baseHue;
                const diff = Math.abs((hue - lastHue + 360) % 360);
                if (diff < 90) {
                    hue = (lastHue + 120 + (hashArray[offset + 2] % 90)) % 360;
                }
                lastHue = hue;
                
                const saturation = 65 + (hashArray[offset + 2] % 30);
                const lightness = 45 + (hashArray[offset + 3] % 25);
                
                // Width varies from 4px to 14px based on hash
                const width = 4 + (hashArray[numBars + i] % 11);
                
                bars.push({ color: `hsl(${hue}, ${saturation}%, ${lightness}%)`, width });
            }
            
            let html = '<div style="display: inline-flex; gap: 0px; margin-right: 10px; vertical-align: middle; height: 16px;">';
            bars.forEach(bar => {
                html += `<div style="width: ${bar.width}px; height: 16px; background: ${bar.color};"></div>`;
            });
            html += '</div>';
            
            return html;
        }
        
        function displayServerInfo(data, containerId) {
            const headersContent = document.getElementById(containerId);
            const headers = data.headers;
            
            let html = '';
            
            // Add protocol info if available
            if (data.protocol) {
                html += `<div class="client-ip"><strong>Protocol:</strong><span class="ip-value">${escapeHtml(data.protocol)}</span></div>`;
            }
            
            // Add client address if available
            if (data.client_addr) {
                html += `<div class="client-ip"><strong>Client Address:</strong><span class="ip-value">${escapeHtml(data.client_addr)}</span></div>`;
            }
            
            // Build server info section
            let serverInfoHtml = '';
            if (data.server_addr || data.hostname || data.node_name) {
                serverInfoHtml += '<div class="server-info">';
                if (data.server_addr) {
                    serverInfoHtml += `<div><strong>Server Address:</strong><span class="info-value">${escapeHtml(data.server_addr)}</span></div>`;
                }
                if (data.hostname) {
                    const insignia = data.hostname_hash ? generateInsignia(data.hostname_hash) : '';
                    serverInfoHtml += `<div style="display: flex; align-items: center;"><strong>Hostname:</strong><span class="info-value" style="display: flex; align-items: center;">${insignia}${escapeHtml(data.hostname)}</span></div>`;
                }
                if (data.node_name) {
                    const insignia = data.node_name_hash ? generateInsignia(data.node_name_hash) : '';
                    serverInfoHtml += `<div style="display: flex; align-items: center;"><strong>Node Name:</strong><span class="info-value" style="display: flex; align-items: center;">${insignia}${escapeHtml(data.node_name)}</span></div>`;
                }
                serverInfoHtml += '</div>';
            }
            
            let tableHtml = '<table class="headers-table"><thead><tr><th>Header Name</th><th>Value</th></tr></thead><tbody>';
            for (const [name, value] of Object.entries(headers)) {
                tableHtml += `<tr><td>${escapeHtml(name)}</td><td>${escapeHtml(value)}</td></tr>`;
            }
            tableHtml += '</tbody></table>';
            
            headersContent.innerHTML = html + serverInfoHtml + tableHtml;
        }
        
        // Display initial server info from page load if available
        if (window.initialServerInfo) {
            displayServerInfo(window.initialServerInfo, 'html-headers-content');
        }
        
        function formatDuration(seconds) {
            if (seconds < 60) return `${seconds}s`;
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}m ${secs}s`;
        }
        
        function addOrUpdateHistory(entry, isUpdate = false) {
            if (isUpdate && history.length > 0) {
                // Update the first entry
                history[0] = entry;
            } else if (entry.error) {
                // Find the first error entry of the same type (WS or SSE)
                const existingErrorIndex = history.findIndex(h => h.error && h.type === entry.type);
                if (existingErrorIndex !== -1) {
                    // Replace the existing error of the same type
                    history[existingErrorIndex] = entry;
                } else {
                    // Add new error entry
                    history.unshift(entry);
                    if (history.length > 20) history.pop();
                }
            } else {
                history.unshift(entry);
                if (history.length > 20) history.pop(); // Keep last 20
            }
            renderHistory([wsManager.getCurrentEntry(), sseManager.getCurrentEntry()]);
        }
        
        function renderHistory(currentConnections) {
            const list = document.getElementById('history-list');
            if (history.length === 0 && currentConnections.every(c => !c)) {
                list.innerHTML = '<li style="color: #95a5a6; text-align: center;">No connections yet</li>';
                return;
            }
            
            const allEntries = [...currentConnections.filter(c => c), ...history];
            allEntries.sort((a, b) => b.timestamp - a.timestamp);
            
            list.innerHTML = allEntries.map(entry => {
                const className = entry.active ? 'success' : entry.error ? 'failure' : 'success';
                const statusClass = entry.active ? 'closed' : entry.error ? 'error' : 'closed';
                let statusText = entry.active ? 'Active' : entry.error ? `Error: ${entry.error}` : 'Closed normally';
                
                if (entry.error && entry.attempts > 1) {
                    statusText += ` (${entry.attempts} attempts)`;
                }
                
                const timestamp = new Date(entry.timestamp).toLocaleTimeString();
                const typeLabel = entry.type === 'SSE' ? 'SSE' : 'WS';
                const typeBadge = `<span style="background: ${entry.type === 'SSE' ? '#6c5ce7' : '#0984e3'}; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.75em; margin-left: 8px;">${typeLabel}</span>`;
                
                return `
                    <li class="history-item ${className}">
                        <div>
                            <span class="time">${timestamp}</span>
                            <span> - Connection #${entry.id}${typeBadge}</span>
                        </div>
                        <div>
                            <span class="duration">${formatDuration(entry.duration)}</span>
                            <span class="status ${statusClass}"> ‚Ä¢ ${statusText}</span>
                        </div>
                    </li>
                `;
            }).join('');
        }
        
        // Generic connection manager factory
        function createConnectionManager(config) {
            let connectionId = 0;
            let currentConnectionEntry = null;
            let failureAttempts = 0;
            let everConnected = false;
            
            function connect() {
                const currentId = ++connectionId;
                const connection = config.createConnection();
                let start = Date.now();
                let timerInterval;
                let connectionOpened = false;
                
                const timer = document.getElementById(config.timerId);
                const statusBadge = document.getElementById(config.statusId);
                const statusText = statusBadge.querySelector('.status-text');
                const msg = document.getElementById(config.msgId);
                
                // Show connecting state
                statusText.innerText = "CONNECTING...";
                statusBadge.className = "status-badge dead";
                msg.innerText = `Attempting ${config.typeLabel} connection #${currentId}...`;
                
                const onOpen = () => {
                    connectionOpened = true;
                    everConnected = true;
                    failureAttempts = 0;
                    
                    statusText.innerText = "CONNECTED";
                    statusBadge.className = "status-badge live";
                    msg.innerText = `${config.typeLabel} connected successfully`;
                    
                    currentConnectionEntry = {
                        id: currentId,
                        timestamp: start,
                        duration: 0,
                        active: true,
                        type: config.type
                    };
                    config.updateHistory();
                    
                    timerInterval = setInterval(() => {
                        const duration = Math.floor((Date.now() - start) / 1000);
                        timer.innerText = duration + "s";
                        if (currentConnectionEntry) {
                            currentConnectionEntry.duration = duration;
                            config.updateHistory();
                        }
                    }, 1000);
                };
                
                const onHeaders = (data) => {
                    displayServerInfo(data, config.headersContentId);
                    msg.innerText = "Headers received";
                };
                
                const onMessage = (text) => {
                    msg.innerText = `Last: ${text}`;
                };
                
                const onError = () => {
                    clearInterval(timerInterval);
                    const duration = Math.floor((Date.now() - start) / 1000);
                    
                    if (connectionOpened) {
                        // Connection was established and then closed
                        statusText.innerText = "DISCONNECTED";
                        statusBadge.className = "status-badge dead";
                        msg.innerText = `Connection closed after ${formatDuration(duration)}. Reconnecting in 2s...`;
                        
                        if (currentConnectionEntry) {
                            currentConnectionEntry.duration = duration;
                            currentConnectionEntry.active = false;
                            history.unshift(currentConnectionEntry);
                            if (history.length > 20) history.pop();
                            currentConnectionEntry = null;
                            config.updateHistory();
                        }
                    } else {
                        // Connection never opened
                        if (everConnected) {
                            failureAttempts++;
                            statusText.innerText = "FAILED";
                            statusBadge.className = "status-badge dead";
                            msg.innerText = `Failed to reconnect (attempt #${currentId}). Retrying in 2s...`;
                            
                            addOrUpdateHistory({
                                id: currentId,
                                timestamp: start,
                                duration: duration,
                                error: 'Failed to connect',
                                attempts: failureAttempts,
                                type: config.type
                            });
                        } else {
                            statusText.innerText = "FAILED";
                            statusBadge.className = "status-badge dead";
                            msg.innerText = `Connection attempt #${currentId} failed. Retrying in 2s...`;
                        }
                    }
                    
                    timer.innerText = "0s";
                    config.closeConnection(connection);
                    setTimeout(connect, 2000);
                };
                
                config.setupHandlers(connection, { onOpen, onHeaders, onMessage, onError });
            }
            
            return { connect, getCurrentEntry: () => currentConnectionEntry };
        }
        
        // WebSocket manager
        const wsManager = createConnectionManager({
            type: 'WebSocket',
            typeLabel: 'WebSocket',
            timerId: 'ws-timer',
            statusId: 'ws-status',
            msgId: 'ws-msg',
            headersContentId: 'ws-headers-content',
            createConnection: () => {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                return new WebSocket(`${protocol}//${window.location.host}${urlPrefix}/ws`);
            },
            closeConnection: (ws) => {},  // WebSocket closes automatically
            updateHistory: () => renderHistory([wsManager.getCurrentEntry(), sseManager.getCurrentEntry()]),
            setupHandlers: (ws, callbacks) => {
                ws.onopen = callbacks.onOpen;
                ws.onmessage = (e) => {
                    try {
                        const data = JSON.parse(e.data);
                        if (data.type === 'headers') {
                            callbacks.onHeaders(data);
                        } else {
                            callbacks.onMessage(e.data);
                        }
                    } catch (err) {
                        callbacks.onMessage(e.data);
                    }
                };
                ws.onerror = () => {};
                ws.onclose = callbacks.onError;
            }
        });
        
        // SSE manager
        const sseManager = createConnectionManager({
            type: 'SSE',
            typeLabel: 'SSE',
            timerId: 'sse-timer',
            statusId: 'sse-status',
            msgId: 'sse-msg',
            headersContentId: 'sse-headers-content',
            createConnection: () => {
                return new EventSource(`${urlPrefix}/sse`);
            },
            closeConnection: (es) => es.close(),
            updateHistory: () => renderHistory([wsManager.getCurrentEntry(), sseManager.getCurrentEntry()]),
            setupHandlers: (es, callbacks) => {
                es.onopen = callbacks.onOpen;
                es.addEventListener('headers', (e) => {
                    try {
                        const data = JSON.parse(e.data);
                        callbacks.onHeaders(data);
                    } catch (err) {
                        console.error('SSE parse error:', err);
                    }
                });
                es.onmessage = (e) => callbacks.onMessage(e.data);
                es.onerror = callbacks.onError;
            }
        });
        
        // Start both connections
        wsManager.connect();
        sseManager.connect();
        
        // Load Balancer Test
        async function runLoadBalancerTest() {
            const button = document.getElementById('lb-test-btn');
            const resultsDiv = document.getElementById('lb-results');
            
            button.disabled = true;
            button.textContent = 'Running...';
            resultsDiv.innerHTML = '<p style="color: #95a5a6; text-align: center; grid-column: 1 / -1;">Making 15 requests...</p>';
            
            const results = [];
            
            // Make 15 requests with cache busting
            for (let i = 0; i < 15; i++) {
                try {
                    const cachebust = Date.now() + Math.random();
                    const response = await fetch(`${urlPrefix}/lb?cb=${cachebust}`);
                    const data = await response.json();
                    results.push({ number: i + 1, data });
                } catch (err) {
                    results.push({ number: i + 1, error: err.message });
                }
            }
            
            // Display results
            let html = '';
            for (const result of results) {
                if (result.error) {
                    html += `
                        <div class="lb-item">
                            <div class="lb-number">#${result.number}</div>
                            <div style="color: #d63031;">Error: ${escapeHtml(result.error)}</div>
                        </div>
                    `;
                } else {
                    const nodeInsignia = result.data.node_name_hash ? generateInsignia(result.data.node_name_hash) : '';
                    const hostnameInsignia = result.data.hostname_hash ? generateInsignia(result.data.hostname_hash) : '';
                    
                    html += `
                        <div class="lb-item">
                            ${result.data.node_name ? `<div class="lb-node">${nodeInsignia}${escapeHtml(result.data.node_name)}</div>` : ''}
                            ${result.data.hostname ? `<div class="lb-hostname">${hostnameInsignia}${escapeHtml(result.data.hostname)}</div>` : ''}
                        </div>
                    `;
                }
            }
            
            resultsDiv.innerHTML = html;
            button.disabled = false;
            button.textContent = 'Reload';
        }
        
        // Proxy Security Test
        async function runProxySecurityTest() {
            const button = document.getElementById('proxy-test-btn');
            const resultsDiv = document.getElementById('proxy-test-results');
            const summaryDiv = document.getElementById('proxy-test-summary');
            const summaryContent = document.getElementById('test-summary');
            
            button.disabled = true;
            button.textContent = 'Testing...';
            resultsDiv.innerHTML = '<p style="color: #95a5a6; text-align: center;">Running security tests...</p>';
            summaryDiv.style.display = 'none';
            
            // Headers that should be stripped by a proper reverse proxy
            // Format: [spoofed value, category, shouldProxySet]
            // shouldProxySet: true = proxy should replace with real value, false = proxy should strip entirely
            const testHeaders = {
                // Critical - highest security impact
                'X-Forwarded-For': ['192.0.2.1, 198.51.100.1', 'critical', true],
                
                // Common - frequently used, important
                'X-Real-IP': ['192.0.2.2', 'common', true],
                'X-Forwarded-Host': ['evil.example.com', 'common', true],
                'X-Forwarded-Proto': ['https', 'common', true],
                'Forwarded': ['for=192.0.2.60;proto=http;by=203.0.113.43', 'common', true],
                'CF-Connecting-IP': ['192.0.2.10', 'common', true],
                'True-Client-IP': ['192.0.2.11', 'common', true],
                'Fastly-Client-IP': ['192.0.2.20', 'common', true],
                'CloudFront-Viewer-Address': ['192.0.2.30:443', 'common', true],
                
                // Uncommon - less frequently used or CDN-specific
                'X-Client-IP': ['192.0.2.3', 'uncommon', true],
                'X-Forwarded-Server': ['evil-server', 'uncommon', true],
                'X-Forwarded-Port': ['8443', 'uncommon', true],
                'X-Forwarded-Scheme': ['https', 'uncommon', true],
                'X-Original-URL': ['/admin/secret', 'uncommon', false],
                'X-Rewrite-URL': ['/admin/secret', 'uncommon', false],
                'X-Host': ['malicious.example.com', 'uncommon', true],
                'X-ProxyUser-Ip': ['192.0.2.4', 'uncommon', true],
                'Client-IP': ['192.0.2.5', 'uncommon', true],
                'X-Cluster-Client-IP': ['192.0.2.6', 'uncommon', true],
                'CF-IPCountry': ['XX', 'uncommon', true],
                'CF-Ray': ['fake-ray-id', 'uncommon', true],
                'CF-Visitor': ['{"scheme":"https"}', 'uncommon', true],
                'CF-Pseudo-IPv4': ['192.0.2.12', 'uncommon', true],
                'Fastly-SSL': ['1', 'uncommon', true],
                'Akamai-Origin-Hop': ['1', 'uncommon', true],
                'CloudFront-Viewer-Country': ['XX', 'uncommon', true],
                'X-Azure-ClientIP': ['192.0.2.40', 'uncommon', true],
                'X-Azure-SocketIP': ['192.0.2.41', 'uncommon', true],
                'X-HTTP-Method-Override': ['DELETE', 'uncommon', false],
                'X-Original-Method': ['DELETE', 'uncommon', false]
            };
            
            try {
                // Make request with test headers
                const headersToSend = {};
                for (const [name, [value, _, __]] of Object.entries(testHeaders)) {
                    headersToSend[name] = value;
                }
                
                const response = await fetch(`${urlPrefix}/echo`, {
                    headers: headersToSend
                });
                
                const data = await response.json();
                const receivedHeaders = data.headers || {};
                
                // Analyze results
                const results = {
                    critical: [],
                    common: [],
                    uncommon: []
                };
                
                const counts = {
                    critical: { pass: 0, warning: 0, fail: 0 },
                    common: { pass: 0, warning: 0, fail: 0 },
                    uncommon: { pass: 0, warning: 0, fail: 0 }
                };
                
                for (const [headerName, [spoofedValue, category, shouldProxySet]] of Object.entries(testHeaders)) {
                    const normalizedName = headerName.toLowerCase();
                    const receivedValue = receivedHeaders[normalizedName];
                    
                    let status, detail, emoji;
                    
                    if (!receivedValue) {
                        // Header was stripped - GOOD
                        status = 'pass';
                        emoji = '‚úÖ';
                        detail = shouldProxySet 
                            ? 'Header stripped (proxy may set it elsewhere)'
                            : 'Header correctly stripped by proxy';
                        counts[category].pass++;
                    } else if (receivedValue === spoofedValue) {
                        // Spoofed value made it through - BAD
                        status = 'fail';
                        emoji = '‚ùå';
                        detail = `SECURITY ISSUE: Spoofed value passed through: ${escapeHtml(receivedValue)}`;
                        counts[category].fail++;
                    } else {
                        // Header present but with different value
                        if (shouldProxySet) {
                            // This is GOOD - proxy set the real value
                            status = 'pass';
                            emoji = '‚úÖ';
                            detail = `Proxy correctly set value: ${escapeHtml(receivedValue)}`;
                            counts[category].pass++;
                        } else {
                            // This is suspicious - why is this header here?
                            status = 'warning';
                            emoji = '‚ö†Ô∏è';
                            detail = `Unexpected: Proxy set value: ${escapeHtml(receivedValue)}`;
                            counts[category].warning++;
                        }
                    }
                    
                    results[category].push({
                        name: headerName,
                        status,
                        emoji,
                        detail
                    });
                }
                
                // Sort results within each category alphabetically
                for (const category of ['critical', 'common', 'uncommon']) {
                    results[category].sort((a, b) => a.name.localeCompare(b.name));
                }
                
                // Calculate totals
                const totalPass = counts.critical.pass + counts.common.pass + counts.uncommon.pass;
                const totalWarning = counts.critical.warning + counts.common.warning + counts.uncommon.warning;
                const totalFail = counts.critical.fail + counts.common.fail + counts.uncommon.fail;
                
                // Display summary
                summaryContent.innerHTML = `
                    <div class="test-stat pass">
                        <div class="count">${totalPass}</div>
                        <div class="label">Passed</div>
                    </div>
                    <div class="test-stat warning">
                        <div class="count">${totalWarning}</div>
                        <div class="label">Warnings</div>
                    </div>
                    <div class="test-stat fail">
                        <div class="count">${totalFail}</div>
                        <div class="label">Failed</div>
                    </div>
                `;
                summaryDiv.style.display = 'block';
                
                // Display detailed results
                let html = '';
                
                // Helper function to render a category section
                const renderCategory = (category, title) => {
                    const categoryResults = results[category];
                    if (categoryResults.length === 0) return '';
                    
                    const categoryTotal = counts[category].pass + counts[category].warning + counts[category].fail;
                    const categorySummary = `${counts[category].pass}‚úÖ ${counts[category].warning}‚ö†Ô∏è ${counts[category].fail}‚ùå`;
                    
                    let section = `
                        <div style="margin-top: 20px; margin-bottom: 10px; padding: 8px 12px; background: #e0e0e0; border-radius: 4px; font-weight: 600; color: #2d3436;">
                            ${title} (${categoryTotal} headers) ‚Äî ${categorySummary}
                        </div>
                    `;
                    
                    for (const result of categoryResults) {
                        section += `
                            <div class="test-result ${result.status}">
                                <div class="test-name">${result.emoji} ${escapeHtml(result.name)}</div>
                                <div class="test-detail">${result.detail}</div>
                            </div>
                        `;
                    }
                    
                    return section;
                };
                
                html += renderCategory('critical', 'üî¥ Critical Headers');
                html += renderCategory('common', 'üü° Common Headers');
                html += renderCategory('uncommon', 'üü¢ Uncommon Headers');
                
                resultsDiv.innerHTML = html;
                
            } catch (err) {
                resultsDiv.innerHTML = `<p style="color: #d63031; text-align: center;">Test failed: ${escapeHtml(err.message)}</p>`;
            }
            
            button.disabled = false;
            button.textContent = 'Run Test';
        }
        
        // Single Header Size Limit Test
        async function runSingleHeaderSizeTest() {
            const button = document.getElementById('single-header-test-btn');
            const resultsDiv = document.getElementById('size-test-results');
            
            button.disabled = true;
            button.textContent = 'Testing...';
            
            // Helper function to test if a header of a given size works
            async function testSize(size) {
                const headerValue = 'x'.repeat(size);
                try {
                    const response = await fetch(`${urlPrefix}/echo`, {
                        headers: {
                            'X-Test-Header': headerValue
                        }
                    });
                    
                    if (!response.ok) {
                        return false;
                    }
                    
                    const data = await response.json();
                    // Verify the header was received
                    return data.headers && data.headers['x-test-header'] === headerValue;
                } catch (err) {
                    return false;
                }
            }
            
            const result = await binarySearchHeaderSize(testSize, resultsDiv, 'single header value');
            
            if (result) {
                displayHeaderSizeResult(resultsDiv, result.maxSize, 'Single Header Value', result.totalTests);
            }
            
            button.disabled = false;
            button.textContent = 'Single Header';
        }
        
        // Total Header Size Limit Test
        async function runTotalHeaderSizeTest() {
            const button = document.getElementById('total-header-test-btn');
            const resultsDiv = document.getElementById('size-test-results');
            
            button.disabled = true;
            button.textContent = 'Testing...';
            
            // Helper function to test if headers totaling a given size work
            async function testSize(totalSize) {
                // Distribute the total size across multiple headers (10 headers)
                const numHeaders = 10;
                const sizePerHeader = Math.floor(totalSize / numHeaders);
                const headerValue = 'x'.repeat(sizePerHeader);
                
                const headers = {};
                for (let i = 0; i < numHeaders; i++) {
                    headers[`X-Test-Header-${i}`] = headerValue;
                }
                
                try {
                    const response = await fetch(`${urlPrefix}/echo`, { headers });
                    
                    if (!response.ok) {
                        return false;
                    }
                    
                    const data = await response.json();
                    // Verify at least one header was received
                    return data.headers && data.headers['x-test-header-0'] === headerValue;
                } catch (err) {
                    return false;
                }
            }
            
            const result = await binarySearchHeaderSize(testSize, resultsDiv, 'total headers size');
            
            if (result) {
                displayHeaderSizeResult(resultsDiv, result.maxSize, 'Total Headers Size', result.totalTests);
            }
            
            button.disabled = false;
            button.textContent = 'Total Headers';
        }
        
        // Binary search for maximum header size
        async function binarySearchHeaderSize(testFunction, resultsDiv, testType) {
            let minSize = 0;
            let maxSize = 1024 * 1024; // Start with 1MB max
            let maxWorkingSize = 0;
            let iterations = 0;
            const maxIterations = 20;
            
            resultsDiv.innerHTML = `
                <div class="size-result">
                    <div style="font-weight: 600; color: #2d3436;">Searching for maximum ${testType}...</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="size-progress" style="width: 0%"></div>
                    </div>
                    <div class="result-detail" id="size-status">Testing...</div>
                </div>
            `;
            
            const progressBar = document.getElementById('size-progress');
            const statusDiv = document.getElementById('size-status');
            
            try {
                // First, quickly find the upper bound by exponential growth
                let currentTestSize = 1024; // Start with 1KB
                statusDiv.textContent = 'Finding upper bound...';
                
                while (await testFunction(currentTestSize) && currentTestSize < maxSize) {
                    maxWorkingSize = currentTestSize;
                    currentTestSize *= 2;
                    progressBar.style.width = '10%';
                }
                
                maxSize = currentTestSize;
                minSize = maxWorkingSize;
                
                // Binary search for exact limit
                while (minSize < maxSize - 1 && iterations < maxIterations) {
                    const midSize = Math.floor((minSize + maxSize) / 2);
                    iterations++;
                    
                    const progress = 10 + (iterations / maxIterations) * 90;
                    progressBar.style.width = `${progress}%`;
                    statusDiv.textContent = `Testing ${formatBytes(midSize)}... (iteration ${iterations}/${maxIterations})`;
                    
                    const works = await testFunction(midSize);
                    
                    if (works) {
                        minSize = midSize;
                        maxWorkingSize = midSize;
                    } else {
                        maxSize = midSize;
                    }
                }
                
                return { maxSize: maxWorkingSize, totalTests: iterations + Math.log2(maxWorkingSize / 1024) };
                
            } catch (err) {
                resultsDiv.innerHTML = `<p style="color: #d63031; text-align: center;">Test failed: ${escapeHtml(err.message)}</p>`;
                return null;
            }
        }
        
        // Display header size test result
        function displayHeaderSizeResult(resultsDiv, maxSize, testType, totalTests) {
            let resultHtml = `
                <div class="size-result">
                    <div style="font-weight: 600; color: #2d3436; margin-bottom: 10px;">Maximum ${testType}</div>
                    <div class="result-value">${formatBytes(maxSize)}</div>
                    <div class="result-detail">
                        üìä ${maxSize.toLocaleString()} bytes (tested in ${Math.ceil(totalTests)} requests)
                    </div>
                    <div class="result-detail" style="margin-top: 10px;">
                        ${getHeaderSizeRecommendation(maxSize)}
                    </div>
                </div>
            `;
            
            resultsDiv.innerHTML = resultHtml;
        }
        
        // Run invalid character test
        async function runInvalidCharacterTest() {
            const resultsDiv = document.getElementById('invalid-char-test-results');
            resultsDiv.innerHTML = '<div class="result-detail">Testing invalid characters in headers...</div>';
            
            // Test various invalid/control characters
            const testCases = [
                { name: 'Null byte (\\x00)', value: 'test\x00value', critical: true },
                { name: 'Carriage Return (\\r)', value: 'test\rvalue', critical: true },
                { name: 'Line Feed (\\n)', value: 'test\nvalue', critical: true },
                { name: 'CRLF injection', value: 'test\r\nInjected-Header: malicious', critical: true },
                { name: 'Vertical Tab (\\v)', value: 'test\vvalue', critical: false },
                { name: 'Form Feed (\\f)', value: 'test\fvalue', critical: false },
                { name: 'Bell (\\x07)', value: 'test\x07value', critical: false },
                { name: 'Backspace (\\x08)', value: 'test\x08value', critical: false },
                { name: 'DEL (\\x7F)', value: 'test\x7Fvalue', critical: false },
                { name: 'High ASCII (\\xFF)', value: 'test\xFFvalue', critical: false }
            ];
            
            const results = [];
            
            for (const testCase of testCases) {
                try {
                    const response = await fetch(`${urlPrefix}/echo`, {
                        headers: {
                            'X-Test-Invalid-Char': testCase.value
                        }
                    });
                    
                    const data = await response.json();
                    const headerFound = data.headers['x-test-invalid-char'] !== undefined;
                    
                    results.push({
                        name: testCase.name,
                        allowed: headerFound,
                        critical: testCase.critical,
                        value: headerFound ? data.headers['x-test-invalid-char'] : null
                    });
                } catch (error) {
                    // Fetch API likely blocked this at the browser level
                    results.push({
                        name: testCase.name,
                        allowed: false,
                        critical: testCase.critical,
                        blocked: true
                    });
                }
            }
            
            // Display results
            const criticalResults = results.filter(r => r.critical);
            const otherResults = results.filter(r => !r.critical);
            
            const passCount = results.filter(r => !r.allowed).length;
            const warnCount = otherResults.filter(r => r.allowed).length;
            const failCount = criticalResults.filter(r => r.allowed).length;
            
            let resultHtml = '<div class="result-summary">';
            resultHtml += `‚úÖ Blocked: ${passCount} | ‚ö†Ô∏è Warnings: ${warnCount} | ‚ùå Critical: ${failCount}`;
            resultHtml += '</div>';
            
            // Critical characters
            resultHtml += '<div class="result-category">Critical Characters (Header Injection Risk)</div>';
            criticalResults.forEach(result => {
                const status = result.allowed ? '‚ùå FAIL' : '‚úÖ PASS';
                const statusClass = result.allowed ? 'fail' : 'success';
                resultHtml += `
                    <div class="result-detail">
                        <span class="${statusClass}">${status}</span> ${result.name}: 
                        ${result.allowed ? 'ALLOWED (Security Risk!)' : 'Blocked'}
                        ${result.blocked ? ' (by browser/fetch API)' : ''}
                    </div>
                `;
            });
            
            // Other control characters
            resultHtml += '<div class="result-category">Other Control Characters</div>';
            otherResults.forEach(result => {
                const status = result.allowed ? '‚ö†Ô∏è WARNING' : '‚úÖ PASS';
                const statusClass = result.allowed ? 'warning' : 'success';
                resultHtml += `
                    <div class="result-detail">
                        <span class="${statusClass}">${status}</span> ${result.name}: 
                        ${result.allowed ? 'Allowed' : 'Blocked'}
                        ${result.blocked ? ' (by browser/fetch API)' : ''}
                    </div>
                `;
            });
            
            resultsDiv.innerHTML = resultHtml;
        }
        
        // Helper function to format bytes
        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            if (bytes < 1024) return bytes + ' Bytes';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }
        
        // Helper function to provide recommendations based on header size
        function getHeaderSizeRecommendation(size) {
            if (size < 4096) {
                return '‚ùå Very restrictive. Will likely break modern authentication (OIDC/OAuth2 with JWTs).';
            } else if (size < 16384) {
                return '‚ö†Ô∏è Minimal limit. May work for simple apps but insufficient for complex OIDC scenarios.';
            } else if (size < 65536) {
                return '‚úÖ Good for most applications. Handles typical OIDC/OAuth2 authentication flows.';
            } else if (size < 131072) {
                return '‚úÖ Generous limit. Accommodates complex OIDC scenarios with multiple tokens.';
            } else if (size < 524288) {
                return '‚ö†Ô∏è Very large limit (common for complex OIDC setups). Monitor for potential abuse.';
            } else {
                return '‚ö†Ô∏è Extremely large limit. May indicate misconfiguration or potential DoS risk. Review if necessary.';
            }
        }
        
        // Auto-run the load balancer test on page load
        runLoadBalancerTest();
    </script>
    
    <div class="footer">
        <div id="version-footer">Loading version...</div>
    </div>
    
    <script>
        // Display version info in footer
        if (window.initialServerInfo) {
            const footer = document.getElementById('version-footer');
            if (window.initialServerInfo.version && window.initialServerInfo.build_time) {
                footer.innerHTML = `<span class="version">Sensillum v${escapeHtml(window.initialServerInfo.version)}</span> (built ${escapeHtml(window.initialServerInfo.build_time)})`;
            }
        }
    </script>
</body>
</html>
